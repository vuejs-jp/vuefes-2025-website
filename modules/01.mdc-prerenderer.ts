import fsp from "node:fs/promises";
import { addComponent, createResolver, defineNuxtModule } from "nuxt/kit";

// Unified and plugins imports
import { unified } from "unified";
import rehypeStringify from "rehype-stringify";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import remarkMDC from "remark-mdc";
import rehypeExternalLinks from "rehype-external-links";

// Types
type RenderedContent = {
  resolvedPath: string;
  content: string;
};

type MdcContent = {
  locale: string;
  relativePath: string;
  content: string;
};

export default defineNuxtModule({
  meta: {
    name: "mdc-prerender-module",
    configKey: "mdcPrerender",
  },

  setup(_options, nuxt) {
    // Initialize paths and processor
    const { resolve } = createResolver(import.meta.url);
    const mdcContentRootDir = resolve("../i18n/");
    const componentsDir = resolve("../app/components/_i18n");

    // Set up unified processor
    const processor = createMarkdownProcessor();

    // Watch for changes in MDC content
    nuxt.options.watch.push(mdcContentRootDir);

    // Register hooks
    setupNitroInitHook();
    setupBuilderWatchHook();

    // Core functions
    function createMarkdownProcessor() {
      return unified()
        .use(remarkParse)
        .use(remarkRehype, { allowDangerousHtml: true })
        .use(remarkMDC)
        .use(rehypeExternalLinks, { target: "_blank" })
        .use(rehypeStringify, { allowDangerousHtml: true });
    }

    function setupNitroInitHook() {
      nuxt.hook("nitro:init", async () => {
        await fsp.rm(componentsDir, { recursive: true, force: true }); // clear
        const rendered = await renderAll();
        await Promise.all(rendered.map(renderedContent => write(renderedContent, true)));
      });
    }

    function setupBuilderWatchHook() {
      nuxt.hook("builder:watch", async (events, path) => {
        if (!path.startsWith(mdcContentRootDir) || !path.endsWith(".md")) return;

        const absolutePath = resolve(mdcContentRootDir, path);
        const relativePath = absolutePath.replace(mdcContentRootDir, "");
        const locale = relativePath.split("/")[relativePath.startsWith("/") ? 1 : 0]!;

        if (["add", "change"].includes(events)) {
          const mdcContent = await parseMdc(path);
          const renderedContent = await render(mdcContent);
          await write(renderedContent, events === "add");
        } else if (events === "unlink") {
          const outputFile = getOutputPath({ locale, relativePath, content: "" });
          await fsp.unlink(outputFile).catch();
        }
      });
    }

    async function renderAll() {
      const files = await fsp.readdir(mdcContentRootDir, { recursive: true });
      const mdcFiles = files.filter(file => file.endsWith(".md"));
      const contents = await Promise.all(mdcFiles.map(async file => parseMdc(file)));
      return await Promise.all(contents.map(mdcContent => render(mdcContent)));
    }

    async function render(mdc: MdcContent): Promise<RenderedContent> {
      const isFaq = mdc.relativePath.endsWith("faq.md");
      const resolvedPath = getOutputPath(mdc);
      const content = await generateComponentContent(mdc, isFaq);
      return { resolvedPath, content };
    }

    async function generateComponentContent(mdc: MdcContent, isFaq: boolean): Promise<string> {
      const PROLOGUE = `<!-- This file is auto-generated by mdc-prerender-module. Do not edit it manually. -->\n\n<template>\n<div data-vf-mdc>\n`;
      const EPILOGUE = `
  </div>
</template>
${isFaq ? generateFaqStyles() : ""}`;

      // Render markdown
      const renderedContent = await (async () => {
        try {
          const rendered = await processor.process(mdc.content);
          return isFaq
            ? renderFAQ(rendered.toString())
            : rendered.toString();
        } catch {
          // Fallback to original content if rendering fails
          return mdc.content;
        }
      })();

      return `${PROLOGUE}${renderedContent}${EPILOGUE}`;
    }

    function generateFaqStyles(): string {
      return `
<style scoped>
@import "~/assets/styles/custom-media-query.css";

h3.faq-q-wrapper {
  display: flex;
  margin-top: 40px;
  @media (--mobile-small) {
    margin-top: 32px;
  }
}

.faq-q,
.faq-a {
  border-radius: 50%;
  width: 28px;
  height: 28px;
  line-height: 28px;
  text-align: center;
  display: inline-block;
  margin-right: 8px;
  margin-top: -4px;
  font-weight: 700;

  @media (--mobile) {
    margin-top: -6px;
  }
}

.faq-q {
  color: var(--color-base);
  border: 1px solid var(--color-base);
}

.faq-a {
  color: var(--color-text-default);
  border: 1px solid var(--color-text-default);
}

.faq-a-content-wrapper {
  margin-top: 14px;
  display: flex;

  @media (--mobile-small) {
    margin-top: 12px;
  }
}

.faq-q-content,
.faq-a-content {
  flex: 1;
}
</style>`;
    }

    function renderFAQ(mdc: string): string {
      // Split content by h3 headers
      const sections = mdc.split(/(?=<h3>)/);

      return sections.map((section) => {
        // Skip empty sections
        if (!section.trim()) return "";

        // Check if this is an h3 section
        if (section.startsWith("<h3>")) {
          // Add Q span to the h3 and wrap in
          const processedHeader = section.replace(
            /<h3>(.*?)<\/h3>/,
            "<h3 class=\"faq-q-wrapper\"><div class=\"faq-q\">Q</div><div class=\"faq-q-content\">$1</div></h3>",
          );

          // Find the content after h3 closing tag
          const matches = processedHeader.match(/<h3 class="faq-q-wrapper">.*?<\/h3>([\s\S]*)/);
          if (matches && matches[1]) {
            // Wrap content with the A structure
            return processedHeader.replace(
              matches[1],
              `<div class="faq-a-content-wrapper"><span class="faq-a">A</span><div class="faq-a-content">${matches[1]}</div></div>`,
            );
          }

          return processedHeader;
        }

        return section;
      }).join("");
    }

    async function parseMdc(path: string): Promise<MdcContent> {
      const absolutePath = resolve(mdcContentRootDir, path);
      const relativePath = absolutePath.replace(mdcContentRootDir, "");
      const locale = relativePath.split("/")[relativePath.startsWith("/") ? 1 : 0]!;
      const content = await fsp.readFile(absolutePath, "utf-8");
      return { locale, relativePath, content };
    }

    async function write(prc: RenderedContent, isNew = false): Promise<void> {
      const { resolvedPath, content } = prc;
      const dir = resolve(resolvedPath, "..");
      await fsp.mkdir(dir, { recursive: true });
      await fsp.writeFile(resolvedPath, content).catch();

      if (isNew) {
        registerComponent(resolvedPath);
      }
    }

    function registerComponent(resolvedPath: string) {
      addComponent({
        name: resolvedPath.replace(/\.vue$/, "").split("/").slice(-1)[0]!,
        filePath: resolvedPath,
        export: "default",
        global: true,
      });
    }

    function getOutputPath(mdc: MdcContent): string {
      // Add locale as prefix
      const componentName = mdc.locale.charAt(0).toUpperCase() + mdc.locale.slice(1)
        + mdc.relativePath
          .replace(/\.md$/, "")
          .split("/")
          // Remove locale name part
          .slice(2)
          // Remove "-"
          .flatMap(part => part.split("-"))
          // To pascal case
          .map(part => part.charAt(0).toUpperCase() + part.slice(1))
          .join("");

      return resolve(componentsDir, mdc.locale, `${componentName}.vue`);
    }
  },
});
