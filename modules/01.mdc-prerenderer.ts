import fsp from "node:fs/promises";
import { addComponent, addComponentsDir, createResolver, defineNuxtModule } from "nuxt/kit";

import { unified } from "unified";
import rehypeStringify from "rehype-stringify";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import remarkMDC from "remark-mdc";
import rehypeExternalLinks from "rehype-external-links";

type RenderedContent = {
  resolvedPath: string;
  content: string;
};

type MdcContent = {
  locale: string;
  relativePath: string;
  content: string;
};

export default defineNuxtModule({
  meta: {
    name: "mdc-prerender-module",
    configKey: "mdcPrerender",
  },

  setup(_options, nuxt) {
    const { resolve } = createResolver(import.meta.url);

    const processor = unified()
      .use(remarkParse)
      .use(remarkRehype)
      .use(remarkMDC)
      .use(rehypeExternalLinks, { target: "_blank" })
      .use(rehypeStringify);

    const mdcContentRootDir = resolve("../i18n/");
    const componentsDir = resolve("../.nuxt/mdc-prerender/components");
    nuxt.options.watch.push(mdcContentRootDir);
    addComponentsDir({ path: componentsDir, pathPrefix: false, prefix: "", global: true });

    // FIXME: does not work...
    nuxt.options.watch.push(componentsDir);

    /*
     * prerendering all mdc files on nitro init
     * ------------------------------------------------------ */
    nuxt.hook("nitro:init", async () => {
      await fsp.rm(componentsDir, { recursive: true, force: true }); // clear
      const rendered = await renderAll();
      await Promise.all(rendered.map(renderedContent => write(renderedContent, true)));
    });

    /*
     * handle mdc file changes
     * ------------------------------------------------------ */
    nuxt.hook("builder:watch", async (events, path) => {
      if (!path.startsWith(mdcContentRootDir)) return;
      if (!path.endsWith(".md")) return;

      const absolutePath = resolve(mdcContentRootDir, path);
      const relativePath = absolutePath.replace(mdcContentRootDir, "");
      const locale = relativePath.split("/")[relativePath.startsWith("/") ? 1 : 0]!;

      if (["add", "change"].includes(events)) {
        const mdcContent = await parseMdc(path);
        const renderedContent = await render(mdcContent);
        await write(renderedContent, events === "add");
      } else if (events === "unlink") {
        const outputFile = getOutputPath({ locale, relativePath, content: "" });
        await fsp.unlink(outputFile).catch();
      }

      // NOTE: force restart because hmr does not work...
      fsp.utimes(resolve("../nuxt.config.ts"), new Date(), new Date()).catch();
    });

    return;

    /*
     * utils
     * ------------------------------------------------------ */

    async function renderAll() {
      const files = await fsp.readdir(mdcContentRootDir, { recursive: true });
      const mdcFiles = files.filter(file => file.endsWith(".md"));
      const contents = await Promise.all(mdcFiles.map(async file => parseMdc(file)));
      return await Promise.all(contents.map(mdcContent => render(mdcContent)));
    }

    async function render(mdc: MdcContent): Promise<RenderedContent> {
      // NOTE: wrapping in "div" to use fallthrough attributes
      const PROLOGUE = `<!-- This file is auto-generated by mdc-prerender-module. Do not edit it manually. -->\n\n<template>\n<div data-vf-mdc>\n`;
      const EPILOGUE = `\n</div>\n</template>\n`;

      const resolvedPath = getOutputPath(mdc);

      // render markdown
      const rendered = `${PROLOGUE}${await (async () => {
        try {
          const rendered = await processor.process(mdc.content);
          return rendered.toString();
        } catch {
          // fallback to original content if rendering fails
          return mdc.content;
        }
      })()}${EPILOGUE}`;

      return { resolvedPath, content: rendered };
    };

    async function parseMdc(path: string): Promise<MdcContent> {
      const absolutePath = resolve(mdcContentRootDir, path);
      const relativePath = absolutePath.replace(mdcContentRootDir, "");
      const locale = relativePath.split("/")[relativePath.startsWith("/") ? 1 : 0]!;
      const content = await fsp.readFile(absolutePath, "utf-8");
      return { locale, relativePath, content };
    }

    async function write(prc: RenderedContent, isNew = false): Promise<void> {
      const { resolvedPath, content } = prc;
      const dir = resolve(resolvedPath, "..");
      await fsp.mkdir(dir, { recursive: true });
      await fsp.writeFile(resolvedPath, content).catch();

      if (isNew) {
        addComponent({
          name: resolvedPath.replace(/\.vue$/, "").split("/").slice(-1)[0]!,
          filePath: resolvedPath,
          export: "default",
          global: true,
        });
      }
    };

    function getOutputPath(mdc: MdcContent): string {
      // add locale as prefix
      const componentName = mdc.locale.charAt(0).toUpperCase() + mdc.locale.slice(1)
        + mdc.relativePath
          .replace(/\.md$/, "")
          .split("/")
        // remove locale name part
          .slice(2)
        // remove "-"
          .flatMap(part => part.split("-"))
        // to pascal case
          .map(part => part.charAt(0).toUpperCase() + part.slice(1))
          .join("");

      return resolve(componentsDir, mdc.locale, `${componentName}.vue`);
    }
  },

});
