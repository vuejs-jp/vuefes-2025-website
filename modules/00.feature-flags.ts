import { defineNuxtModule, addTemplate } from "nuxt/kit";

export interface FeatureFlags {
  [key: string]: boolean;
}

export type ModuleOptions = FeatureFlags;

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: "feature-flags",
    configKey: "featureFlags",
  },
  defaults: {},
  async setup(options, nuxt) {
    const featureFlags = options || {};
    const defines: Record<string, string> = {};
    for (const [key, value] of Object.entries(featureFlags)) {
      defines[`import.meta.vfFeatures.${key}`] = JSON.stringify(value);
    }

    const typeContent = generateTypeDeclarations(featureFlags);

    /**
     * For client (Nuxt Vite)
     ---------------------------------------------------------------------------- */

    nuxt.options.vite = nuxt.options.vite || {};
    nuxt.options.vite.define = {
      ...nuxt.options.vite.define,
      ...defines,
    };

    addTemplate({
      filename: "types/feature-flags.d.ts",
      getContents: () => typeContent,
      write: true,
    });

    nuxt.hook("prepare:types", async ({ references }) => {
      references.push({ path: "./types/feature-flags.d.ts" });
    });

    /**
     * For server (Nitro)
     ---------------------------------------------------------------------------- */

    nuxt.options.nitro = nuxt.options.nitro || {};
    nuxt.options.nitro.esbuild = nuxt.options.nitro.esbuild || {};
    nuxt.options.nitro.esbuild.options = nuxt.options.nitro.esbuild.options || {};
    nuxt.options.nitro.esbuild.options.define = { ...nuxt.options.nitro.esbuild.options.define, ...defines };
    nuxt.options.nitro.replace = { ...nuxt.options.nitro.replace, ...defines };

    addTemplate({
      filename: "types/nitro-feature-flags.d.ts",
      getContents: () => typeContent,
      write: true,
    });

    nuxt.hook("nitro:config", (nitroConfig) => {
      nitroConfig.typescript = nitroConfig.typescript || {};
      nitroConfig.typescript.tsConfig = nitroConfig.typescript.tsConfig || {};
      nitroConfig.typescript.tsConfig.compilerOptions = nitroConfig.typescript.tsConfig.compilerOptions || {};
      nitroConfig.typescript.tsConfig.compilerOptions.types = nitroConfig.typescript.tsConfig.compilerOptions.types || [];
      if (Array.isArray(nitroConfig.typescript.tsConfig.compilerOptions.types)) {
        nitroConfig.typescript.tsConfig.compilerOptions.types.push(".nuxt/types/nitro-feature-flags");
      }
    });

    nuxt.hook("prepare:types", async ({ references }) => {
      references.push({ path: "./types/nitro-feature-flags.d.ts" });
    });
  },
});

function generateTypeDeclarations(featureFlags: FeatureFlags): string {
  const flagTypes = Object.entries(featureFlags)
    .map(([key, value]) => `    readonly ${key}: ${typeof value};`)
    .join("\n");

  return `// Auto-generated feature flags type definitions
// Do not edit this file directly

declare global {
  interface ImportMetaFeatureFlags {
${flagTypes}
  }

  interface ImportMeta {
    readonly vfFeatures: ImportMetaFeatureFlags;
  }
}

export {};
`;
}
