import { readFileSync, existsSync, writeFileSync, mkdirSync } from "node:fs";

import { defineNuxtModule, createResolver } from "nuxt/kit";
import { parse } from "yaml";

type Yaml = { [key: string]: string | Yaml };

export default defineNuxtModule({
  meta: {
    name: "server-i18n",
  },
  setup(_options, nuxt) {
    const { resolve } = createResolver(import.meta.url);

    const locales = ["ja", "en"];

    // Load and parse YAML files
    function loadTranslations(locale: string): Yaml {
      const filePath = resolve(`../i18n/${locale}/index.yaml`);
      nuxt.options.watch.push(filePath);
      if (!existsSync(filePath)) {
        console.warn(`Translation file not found: ${filePath}`);
        return {};
      }

      try {
        const content = readFileSync(filePath, "utf-8");
        return parse(content);
      } catch (error) {
        console.error(`Failed to parse YAML file: ${filePath}`, error);
        return {};
      }
    }

    function extractKeys(obj: Yaml, prefix = ""): string[] {
      const keys: string[] = [];

      for (const key in obj) {
        const fullKey = prefix ? `${prefix}.${key}` : key;

        if (obj[key] && typeof obj[key] === "object" && !Array.isArray(obj[key])) {
          keys.push(...extractKeys(obj[key], fullKey));
        } else {
          keys.push(fullKey);
        }
      }

      return keys;
    }

    // Generate TypeScript type definition
    function generateTypeDefinition(keys: string[]): string {
      const sortedKeys = [...new Set(keys)].sort();
      const keysUnion = sortedKeys.map(key => `  | "${key}"`).join("\n");

      return `// Auto-generated translation keys
// DO NOT EDIT THIS FILE MANUALLY

export type TranslationKey = 
${keysUnion};
`;
    }

    // Generate translations JSON files and types
    function generateTranslationFiles() {
      const allKeys = new Set<string>();
      const translationsData: Record<string, Yaml> = {};

      // Load all translations
      for (const locale of locales) {
        const translations = loadTranslations(locale);
        translationsData[locale] = translations;
        const keys = extractKeys(translations);
        keys.forEach(key => allKeys.add(key));
      }

      // Ensure directory exists
      const i18nDir = resolve("../server/i18n/generated");
      if (!existsSync(i18nDir)) {
        mkdirSync(i18nDir, { recursive: true });
      }

      // Generate JSON files for each locale
      for (const locale of locales) {
        const jsonPath = resolve(`../server/i18n/generated/${locale}.json`);
        writeFileSync(jsonPath, JSON.stringify(translationsData[locale], null, 2), "utf-8");
      }

      // Generate TypeScript type definition
      const typeDefinition = generateTypeDefinition(Array.from(allKeys));
      const typesPath = resolve("../server/i18n/generated/types.ts");
      writeFileSync(typesPath, typeDefinition, "utf-8");

      // Generate index file that exports all translations
      const indexContent = `// Auto-generated translation exports
// DO NOT EDIT THIS FILE MANUALLY

import ja from "./ja.json";
import en from "./en.json";

export const translations = {
  ja,
  en,
} as const;

export type Locale = keyof typeof translations;
`;
      const indexPath = resolve("../server/i18n/generated/translations.ts");
      writeFileSync(indexPath, indexContent, "utf-8");
    }

    // Generate files on build
    generateTranslationFiles();

    // Watch for changes in translation files during development
    if (nuxt.options.dev) {
      nuxt.hook("builder:watch", async (_event, path) => {
        if (path.includes("i18n") && path.endsWith(".yaml")) {
          console.log("Translation file changed, regenerating files...");
          generateTranslationFiles();
        }
      });
    }
  },
});
